"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-simple-code-editor";
exports.ids = ["vendor-chunks/react-simple-code-editor"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-simple-code-editor/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-simple-code-editor/lib/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar React = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = typeof window !== 'undefined' &&\n    'navigator' in window &&\n    /Win/i.test(navigator.platform);\nvar isMacLike = typeof window !== 'undefined' &&\n    'navigator' in window &&\n    /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar className = 'npm__react-simple-code-editor__textarea';\nvar cssText = /* CSS */ \"\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.\".concat(className, \":empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn't support '-webkit-text-fill-color'\\n    * So we use 'color: transparent' to make the text transparent on IE\\n    * Unlike other browsers, it doesn't affect caret color in IE\\n    */\\n  .\").concat(className, \" {\\n    color: transparent !important;\\n  }\\n\\n  .\").concat(className, \"::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n\");\nvar Editor = React.forwardRef(function Editor(props, ref) {\n    var autoFocus = props.autoFocus, disabled = props.disabled, form = props.form, highlight = props.highlight, _a = props.ignoreTabKey, ignoreTabKey = _a === void 0 ? false : _a, _b = props.insertSpaces, insertSpaces = _b === void 0 ? true : _b, maxLength = props.maxLength, minLength = props.minLength, name = props.name, onBlur = props.onBlur, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onValueChange = props.onValueChange, _c = props.padding, padding = _c === void 0 ? 0 : _c, placeholder = props.placeholder, preClassName = props.preClassName, readOnly = props.readOnly, required = props.required, style = props.style, _d = props.tabSize, tabSize = _d === void 0 ? 2 : _d, textareaClassName = props.textareaClassName, textareaId = props.textareaId, value = props.value, rest = __rest(props, [\"autoFocus\", \"disabled\", \"form\", \"highlight\", \"ignoreTabKey\", \"insertSpaces\", \"maxLength\", \"minLength\", \"name\", \"onBlur\", \"onClick\", \"onFocus\", \"onKeyDown\", \"onKeyUp\", \"onValueChange\", \"padding\", \"placeholder\", \"preClassName\", \"readOnly\", \"required\", \"style\", \"tabSize\", \"textareaClassName\", \"textareaId\", \"value\"]);\n    var historyRef = React.useRef({\n        stack: [],\n        offset: -1,\n    });\n    var inputRef = React.useRef(null);\n    var _e = React.useState(true), capture = _e[0], setCapture = _e[1];\n    var contentStyle = {\n        paddingTop: typeof padding === 'object' ? padding.top : padding,\n        paddingRight: typeof padding === 'object' ? padding.right : padding,\n        paddingBottom: typeof padding === 'object' ? padding.bottom : padding,\n        paddingLeft: typeof padding === 'object' ? padding.left : padding,\n    };\n    var highlighted = highlight(value);\n    var getLines = function (text, position) {\n        return text.substring(0, position).split('\\n');\n    };\n    var recordChange = React.useCallback(function (record, overwrite) {\n        var _a, _b, _c;\n        if (overwrite === void 0) { overwrite = false; }\n        var _d = historyRef.current, stack = _d.stack, offset = _d.offset;\n        if (stack.length && offset > -1) {\n            // When something updates, drop the redo operations\n            historyRef.current.stack = stack.slice(0, offset + 1);\n            // Limit the number of operations to 100\n            var count = historyRef.current.stack.length;\n            if (count > HISTORY_LIMIT) {\n                var extras = count - HISTORY_LIMIT;\n                historyRef.current.stack = stack.slice(extras, count);\n                historyRef.current.offset = Math.max(historyRef.current.offset - extras, 0);\n            }\n        }\n        var timestamp = Date.now();\n        if (overwrite) {\n            var last = historyRef.current.stack[historyRef.current.offset];\n            if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n                // A previous entry exists and was in short interval\n                // Match the last word in the line\n                var re = /[^a-z0-9]([a-z0-9]+)$/i;\n                // Get the previous line\n                var previous = (_a = getLines(last.value, last.selectionStart)\n                    .pop()) === null || _a === void 0 ? void 0 : _a.match(re);\n                // Get the current line\n                var current = (_b = getLines(record.value, record.selectionStart)\n                    .pop()) === null || _b === void 0 ? void 0 : _b.match(re);\n                if ((previous === null || previous === void 0 ? void 0 : previous[1]) && ((_c = current === null || current === void 0 ? void 0 : current[1]) === null || _c === void 0 ? void 0 : _c.startsWith(previous[1]))) {\n                    // The last word of the previous line and current line match\n                    // Overwrite previous entry so that undo will remove whole word\n                    historyRef.current.stack[historyRef.current.offset] = __assign(__assign({}, record), { timestamp: timestamp });\n                    return;\n                }\n            }\n        }\n        // Add the new operation to the stack\n        historyRef.current.stack.push(__assign(__assign({}, record), { timestamp: timestamp }));\n        historyRef.current.offset++;\n    }, []);\n    var recordCurrentState = React.useCallback(function () {\n        var input = inputRef.current;\n        if (!input)\n            return;\n        // Save current state of the input\n        var value = input.value, selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;\n        recordChange({\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd,\n        });\n    }, [recordChange]);\n    var updateInput = function (record) {\n        var input = inputRef.current;\n        if (!input)\n            return;\n        // Update values and selection state\n        input.value = record.value;\n        input.selectionStart = record.selectionStart;\n        input.selectionEnd = record.selectionEnd;\n        onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(record.value);\n    };\n    var applyEdits = function (record) {\n        // Save last selection state\n        var input = inputRef.current;\n        var last = historyRef.current.stack[historyRef.current.offset];\n        if (last && input) {\n            historyRef.current.stack[historyRef.current.offset] = __assign(__assign({}, last), { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd });\n        }\n        // Save the changes\n        recordChange(record);\n        updateInput(record);\n    };\n    var undoEdit = function () {\n        var _a = historyRef.current, stack = _a.stack, offset = _a.offset;\n        // Get the previous edit\n        var record = stack[offset - 1];\n        if (record) {\n            // Apply the changes and update the offset\n            updateInput(record);\n            historyRef.current.offset = Math.max(offset - 1, 0);\n        }\n    };\n    var redoEdit = function () {\n        var _a = historyRef.current, stack = _a.stack, offset = _a.offset;\n        // Get the next edit\n        var record = stack[offset + 1];\n        if (record) {\n            // Apply the changes and update the offset\n            updateInput(record);\n            historyRef.current.offset = Math.min(offset + 1, stack.length - 1);\n        }\n    };\n    var handleKeyDown = function (e) {\n        if (onKeyDown) {\n            onKeyDown(e);\n            if (e.defaultPrevented) {\n                return;\n            }\n        }\n        if (e.key === 'Escape') {\n            e.currentTarget.blur();\n        }\n        var _a = e.currentTarget, value = _a.value, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n        var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n        if (e.key === 'Tab' && !ignoreTabKey && capture) {\n            // Prevent focus change\n            e.preventDefault();\n            if (e.shiftKey) {\n                // Unindent selected lines\n                var linesBeforeCaret = getLines(value, selectionStart);\n                var startLine_1 = linesBeforeCaret.length - 1;\n                var endLine_1 = getLines(value, selectionEnd).length - 1;\n                var nextValue = value\n                    .split('\\n')\n                    .map(function (line, i) {\n                    if (i >= startLine_1 &&\n                        i <= endLine_1 &&\n                        line.startsWith(tabCharacter)) {\n                        return line.substring(tabCharacter.length);\n                    }\n                    return line;\n                })\n                    .join('\\n');\n                if (value !== nextValue) {\n                    var startLineText = linesBeforeCaret[startLine_1];\n                    applyEdits({\n                        value: nextValue,\n                        // Move the start cursor if first line in selection was modified\n                        // It was modified only if it started with a tab\n                        selectionStart: (startLineText === null || startLineText === void 0 ? void 0 : startLineText.startsWith(tabCharacter))\n                            ? selectionStart - tabCharacter.length\n                            : selectionStart,\n                        // Move the end cursor by total number of characters removed\n                        selectionEnd: selectionEnd - (value.length - nextValue.length),\n                    });\n                }\n            }\n            else if (selectionStart !== selectionEnd) {\n                // Indent selected lines\n                var linesBeforeCaret = getLines(value, selectionStart);\n                var startLine_2 = linesBeforeCaret.length - 1;\n                var endLine_2 = getLines(value, selectionEnd).length - 1;\n                var startLineText = linesBeforeCaret[startLine_2];\n                applyEdits({\n                    value: value\n                        .split('\\n')\n                        .map(function (line, i) {\n                        if (i >= startLine_2 && i <= endLine_2) {\n                            return tabCharacter + line;\n                        }\n                        return line;\n                    })\n                        .join('\\n'),\n                    // Move the start cursor by number of characters added in first line of selection\n                    // Don't move it if it there was no text before cursor\n                    selectionStart: startLineText && /\\S/.test(startLineText)\n                        ? selectionStart + tabCharacter.length\n                        : selectionStart,\n                    // Move the end cursor by total number of characters added\n                    selectionEnd: selectionEnd + tabCharacter.length * (endLine_2 - startLine_2 + 1),\n                });\n            }\n            else {\n                var updatedSelection = selectionStart + tabCharacter.length;\n                applyEdits({\n                    // Insert tab character at caret\n                    value: value.substring(0, selectionStart) +\n                        tabCharacter +\n                        value.substring(selectionEnd),\n                    // Update caret position\n                    selectionStart: updatedSelection,\n                    selectionEnd: updatedSelection,\n                });\n            }\n        }\n        else if (e.key === 'Backspace') {\n            var hasSelection = selectionStart !== selectionEnd;\n            var textBeforeCaret = value.substring(0, selectionStart);\n            if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n                // Prevent default delete behaviour\n                e.preventDefault();\n                var updatedSelection = selectionStart - tabCharacter.length;\n                applyEdits({\n                    // Remove tab character at caret\n                    value: value.substring(0, selectionStart - tabCharacter.length) +\n                        value.substring(selectionEnd),\n                    // Update caret position\n                    selectionStart: updatedSelection,\n                    selectionEnd: updatedSelection,\n                });\n            }\n        }\n        else if (e.key === 'Enter') {\n            // Ignore selections\n            if (selectionStart === selectionEnd) {\n                // Get the current line\n                var line = getLines(value, selectionStart).pop();\n                var matches = line === null || line === void 0 ? void 0 : line.match(/^\\s+/);\n                if (matches === null || matches === void 0 ? void 0 : matches[0]) {\n                    e.preventDefault();\n                    // Preserve indentation on inserting a new line\n                    var indent = '\\n' + matches[0];\n                    var updatedSelection = selectionStart + indent.length;\n                    applyEdits({\n                        // Insert indentation character at caret\n                        value: value.substring(0, selectionStart) +\n                            indent +\n                            value.substring(selectionEnd),\n                        // Update caret position\n                        selectionStart: updatedSelection,\n                        selectionEnd: updatedSelection,\n                    });\n                }\n            }\n        }\n        else if (e.keyCode === KEYCODE_PARENS ||\n            e.keyCode === KEYCODE_BRACKETS ||\n            e.keyCode === KEYCODE_QUOTE ||\n            e.keyCode === KEYCODE_BACK_QUOTE) {\n            var chars = void 0;\n            if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n                chars = ['(', ')'];\n            }\n            else if (e.keyCode === KEYCODE_BRACKETS) {\n                if (e.shiftKey) {\n                    chars = ['{', '}'];\n                }\n                else {\n                    chars = ['[', ']'];\n                }\n            }\n            else if (e.keyCode === KEYCODE_QUOTE) {\n                if (e.shiftKey) {\n                    chars = ['\"', '\"'];\n                }\n                else {\n                    chars = [\"'\", \"'\"];\n                }\n            }\n            else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n                chars = ['`', '`'];\n            }\n            // If text is selected, wrap them in the characters\n            if (selectionStart !== selectionEnd && chars) {\n                e.preventDefault();\n                applyEdits({\n                    value: value.substring(0, selectionStart) +\n                        chars[0] +\n                        value.substring(selectionStart, selectionEnd) +\n                        chars[1] +\n                        value.substring(selectionEnd),\n                    // Update caret position\n                    selectionStart: selectionStart,\n                    selectionEnd: selectionEnd + 2,\n                });\n            }\n        }\n        else if ((isMacLike\n            ? // Trigger undo with ⌘+Z on Mac\n                e.metaKey && e.keyCode === KEYCODE_Z\n            : // Trigger undo with Ctrl+Z on other platforms\n                e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n            !e.shiftKey &&\n            !e.altKey) {\n            e.preventDefault();\n            undoEdit();\n        }\n        else if ((isMacLike\n            ? // Trigger redo with ⌘+Shift+Z on Mac\n                e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n            : isWindows\n                ? // Trigger redo with Ctrl+Y on Windows\n                    e.ctrlKey && e.keyCode === KEYCODE_Y\n                : // Trigger redo with Ctrl+Shift+Z on other platforms\n                    e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n            !e.altKey) {\n            e.preventDefault();\n            redoEdit();\n        }\n        else if (e.keyCode === KEYCODE_M &&\n            e.ctrlKey &&\n            (isMacLike ? e.shiftKey : true)) {\n            e.preventDefault();\n            // Toggle capturing tab key so users can focus away\n            setCapture(function (prev) { return !prev; });\n        }\n    };\n    var handleChange = function (e) {\n        var _a = e.currentTarget, value = _a.value, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n        recordChange({\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd,\n        }, true);\n        onValueChange(value);\n    };\n    React.useEffect(function () {\n        recordCurrentState();\n    }, [recordCurrentState]);\n    React.useImperativeHandle(ref, function () {\n        return {\n            get session() {\n                return {\n                    history: historyRef.current,\n                };\n            },\n            set session(session) {\n                historyRef.current = session.history;\n            },\n        };\n    }, []);\n    return (React.createElement(\"div\", __assign({}, rest, { style: __assign(__assign({}, styles.container), style) }),\n        React.createElement(\"pre\", __assign({ className: preClassName, \"aria-hidden\": \"true\", style: __assign(__assign(__assign({}, styles.editor), styles.highlight), contentStyle) }, (typeof highlighted === 'string'\n            ? { dangerouslySetInnerHTML: { __html: highlighted + '<br />' } }\n            : { children: highlighted }))),\n        React.createElement(\"textarea\", { ref: function (c) { return (inputRef.current = c); }, style: __assign(__assign(__assign({}, styles.editor), styles.textarea), contentStyle), className: className + (textareaClassName ? \" \".concat(textareaClassName) : ''), id: textareaId, value: value, onChange: handleChange, onKeyDown: handleKeyDown, onClick: onClick, onKeyUp: onKeyUp, onFocus: onFocus, onBlur: onBlur, disabled: disabled, form: form, maxLength: maxLength, minLength: minLength, name: name, placeholder: placeholder, readOnly: readOnly, required: required, autoFocus: autoFocus, autoCapitalize: \"off\", autoComplete: \"off\", autoCorrect: \"off\", spellCheck: false, \"data-gramm\": false }),\n        React.createElement(\"style\", { dangerouslySetInnerHTML: { __html: cssText } })));\n});\nvar styles = {\n    container: {\n        position: 'relative',\n        textAlign: 'left',\n        boxSizing: 'border-box',\n        padding: 0,\n        overflow: 'hidden',\n    },\n    textarea: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        height: '100%',\n        width: '100%',\n        resize: 'none',\n        color: 'inherit',\n        overflow: 'hidden',\n        MozOsxFontSmoothing: 'grayscale',\n        WebkitFontSmoothing: 'antialiased',\n        WebkitTextFillColor: 'transparent',\n    },\n    highlight: {\n        position: 'relative',\n        pointerEvents: 'none',\n    },\n    editor: {\n        margin: 0,\n        border: 0,\n        background: 'none',\n        boxSizing: 'inherit',\n        display: 'inherit',\n        fontFamily: 'inherit',\n        fontSize: 'inherit',\n        fontStyle: 'inherit',\n        fontVariantLigatures: 'inherit',\n        fontWeight: 'inherit',\n        letterSpacing: 'inherit',\n        lineHeight: 'inherit',\n        tabSize: 'inherit',\n        textIndent: 'inherit',\n        textRendering: 'inherit',\n        textTransform: 'inherit',\n        whiteSpace: 'pre-wrap',\n        wordBreak: 'keep-all',\n        overflowWrap: 'break-word',\n    },\n};\nexports[\"default\"] = Editor;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWNvZGUtZWRpdG9yL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixtQkFBTyxDQUFDLHdHQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLGdEQUFnRCxHQUFHLG9JQUFvSSwyT0FBMk8sb0NBQW9DLEtBQUssMENBQTBDLDJDQUEyQyxvQ0FBb0MsS0FBSyxHQUFHO0FBQzVzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYSxzQkFBc0I7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWNvZGUtZWRpdG9yL2xpYi9pbmRleC5qcz83ZjU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgS0VZQ09ERV9ZID0gODk7XG52YXIgS0VZQ09ERV9aID0gOTA7XG52YXIgS0VZQ09ERV9NID0gNzc7XG52YXIgS0VZQ09ERV9QQVJFTlMgPSA1NztcbnZhciBLRVlDT0RFX0JSQUNLRVRTID0gMjE5O1xudmFyIEtFWUNPREVfUVVPVEUgPSAyMjI7XG52YXIgS0VZQ09ERV9CQUNLX1FVT1RFID0gMTkyO1xudmFyIEhJU1RPUllfTElNSVQgPSAxMDA7XG52YXIgSElTVE9SWV9USU1FX0dBUCA9IDMwMDA7XG52YXIgaXNXaW5kb3dzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnbmF2aWdhdG9yJyBpbiB3aW5kb3cgJiZcbiAgICAvV2luL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xudmFyIGlzTWFjTGlrZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ25hdmlnYXRvcicgaW4gd2luZG93ICYmXG4gICAgLyhNYWN8aVBob25lfGlQb2R8aVBhZCkvaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgY2xhc3NOYW1lID0gJ25wbV9fcmVhY3Qtc2ltcGxlLWNvZGUtZWRpdG9yX190ZXh0YXJlYSc7XG52YXIgY3NzVGV4dCA9IC8qIENTUyAqLyBcIlxcbi8qKlxcbiAqIFJlc2V0IHRoZSB0ZXh0IGZpbGwgY29sb3Igc28gdGhhdCBwbGFjZWhvbGRlciBpcyB2aXNpYmxlXFxuICovXFxuLlwiLmNvbmNhdChjbGFzc05hbWUsIFwiOmVtcHR5IHtcXG4gIC13ZWJraXQtdGV4dC1maWxsLWNvbG9yOiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxufVxcblxcbi8qKlxcbiAqIEhhY2sgdG8gYXBwbHkgb24gc29tZSBDU1Mgb24gSUUxMCBhbmQgSUUxMVxcbiAqL1xcbkBtZWRpYSBhbGwgYW5kICgtbXMtaGlnaC1jb250cmFzdDogbm9uZSksICgtbXMtaGlnaC1jb250cmFzdDogYWN0aXZlKSB7XFxuICAvKipcXG4gICAgKiBJRSBkb2Vzbid0IHN1cHBvcnQgJy13ZWJraXQtdGV4dC1maWxsLWNvbG9yJ1xcbiAgICAqIFNvIHdlIHVzZSAnY29sb3I6IHRyYW5zcGFyZW50JyB0byBtYWtlIHRoZSB0ZXh0IHRyYW5zcGFyZW50IG9uIElFXFxuICAgICogVW5saWtlIG90aGVyIGJyb3dzZXJzLCBpdCBkb2Vzbid0IGFmZmVjdCBjYXJldCBjb2xvciBpbiBJRVxcbiAgICAqL1xcbiAgLlwiKS5jb25jYXQoY2xhc3NOYW1lLCBcIiB7XFxuICAgIGNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcbiAgfVxcblxcbiAgLlwiKS5jb25jYXQoY2xhc3NOYW1lLCBcIjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2FjY2VmNyAhaW1wb3J0YW50O1xcbiAgICBjb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXG4gIH1cXG59XFxuXCIpO1xudmFyIEVkaXRvciA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRWRpdG9yKHByb3BzLCByZWYpIHtcbiAgICB2YXIgYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLCBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLCBmb3JtID0gcHJvcHMuZm9ybSwgaGlnaGxpZ2h0ID0gcHJvcHMuaGlnaGxpZ2h0LCBfYSA9IHByb3BzLmlnbm9yZVRhYktleSwgaWdub3JlVGFiS2V5ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gcHJvcHMuaW5zZXJ0U3BhY2VzLCBpbnNlcnRTcGFjZXMgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBtYXhMZW5ndGggPSBwcm9wcy5tYXhMZW5ndGgsIG1pbkxlbmd0aCA9IHByb3BzLm1pbkxlbmd0aCwgbmFtZSA9IHByb3BzLm5hbWUsIG9uQmx1ciA9IHByb3BzLm9uQmx1ciwgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssIG9uRm9jdXMgPSBwcm9wcy5vbkZvY3VzLCBvbktleURvd24gPSBwcm9wcy5vbktleURvd24sIG9uS2V5VXAgPSBwcm9wcy5vbktleVVwLCBvblZhbHVlQ2hhbmdlID0gcHJvcHMub25WYWx1ZUNoYW5nZSwgX2MgPSBwcm9wcy5wYWRkaW5nLCBwYWRkaW5nID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgcGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlciwgcHJlQ2xhc3NOYW1lID0gcHJvcHMucHJlQ2xhc3NOYW1lLCByZWFkT25seSA9IHByb3BzLnJlYWRPbmx5LCByZXF1aXJlZCA9IHByb3BzLnJlcXVpcmVkLCBzdHlsZSA9IHByb3BzLnN0eWxlLCBfZCA9IHByb3BzLnRhYlNpemUsIHRhYlNpemUgPSBfZCA9PT0gdm9pZCAwID8gMiA6IF9kLCB0ZXh0YXJlYUNsYXNzTmFtZSA9IHByb3BzLnRleHRhcmVhQ2xhc3NOYW1lLCB0ZXh0YXJlYUlkID0gcHJvcHMudGV4dGFyZWFJZCwgdmFsdWUgPSBwcm9wcy52YWx1ZSwgcmVzdCA9IF9fcmVzdChwcm9wcywgW1wiYXV0b0ZvY3VzXCIsIFwiZGlzYWJsZWRcIiwgXCJmb3JtXCIsIFwiaGlnaGxpZ2h0XCIsIFwiaWdub3JlVGFiS2V5XCIsIFwiaW5zZXJ0U3BhY2VzXCIsIFwibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCIsIFwibmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2xpY2tcIiwgXCJvbkZvY3VzXCIsIFwib25LZXlEb3duXCIsIFwib25LZXlVcFwiLCBcIm9uVmFsdWVDaGFuZ2VcIiwgXCJwYWRkaW5nXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJwcmVDbGFzc05hbWVcIiwgXCJyZWFkT25seVwiLCBcInJlcXVpcmVkXCIsIFwic3R5bGVcIiwgXCJ0YWJTaXplXCIsIFwidGV4dGFyZWFDbGFzc05hbWVcIiwgXCJ0ZXh0YXJlYUlkXCIsIFwidmFsdWVcIl0pO1xuICAgIHZhciBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgc3RhY2s6IFtdLFxuICAgICAgICBvZmZzZXQ6IC0xLFxuICAgIH0pO1xuICAgIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgX2UgPSBSZWFjdC51c2VTdGF0ZSh0cnVlKSwgY2FwdHVyZSA9IF9lWzBdLCBzZXRDYXB0dXJlID0gX2VbMV07XG4gICAgdmFyIGNvbnRlbnRTdHlsZSA9IHtcbiAgICAgICAgcGFkZGluZ1RvcDogdHlwZW9mIHBhZGRpbmcgPT09ICdvYmplY3QnID8gcGFkZGluZy50b3AgOiBwYWRkaW5nLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0JyA/IHBhZGRpbmcucmlnaHQgOiBwYWRkaW5nLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiB0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcgPyBwYWRkaW5nLmJvdHRvbSA6IHBhZGRpbmcsXG4gICAgICAgIHBhZGRpbmdMZWZ0OiB0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcgPyBwYWRkaW5nLmxlZnQgOiBwYWRkaW5nLFxuICAgIH07XG4gICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0KHZhbHVlKTtcbiAgICB2YXIgZ2V0TGluZXMgPSBmdW5jdGlvbiAodGV4dCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKS5zcGxpdCgnXFxuJyk7XG4gICAgfTtcbiAgICB2YXIgcmVjb3JkQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJlY29yZCwgb3ZlcndyaXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAob3ZlcndyaXRlID09PSB2b2lkIDApIHsgb3ZlcndyaXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9kID0gaGlzdG9yeVJlZi5jdXJyZW50LCBzdGFjayA9IF9kLnN0YWNrLCBvZmZzZXQgPSBfZC5vZmZzZXQ7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggJiYgb2Zmc2V0ID4gLTEpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gc29tZXRoaW5nIHVwZGF0ZXMsIGRyb3AgdGhlIHJlZG8gb3BlcmF0aW9uc1xuICAgICAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50LnN0YWNrID0gc3RhY2suc2xpY2UoMCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAvLyBMaW1pdCB0aGUgbnVtYmVyIG9mIG9wZXJhdGlvbnMgdG8gMTAwXG4gICAgICAgICAgICB2YXIgY291bnQgPSBoaXN0b3J5UmVmLmN1cnJlbnQuc3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvdW50ID4gSElTVE9SWV9MSU1JVCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYXMgPSBjb3VudCAtIEhJU1RPUllfTElNSVQ7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50LnN0YWNrID0gc3RhY2suc2xpY2UoZXh0cmFzLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50Lm9mZnNldCA9IE1hdGgubWF4KGhpc3RvcnlSZWYuY3VycmVudC5vZmZzZXQgLSBleHRyYXMsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGhpc3RvcnlSZWYuY3VycmVudC5zdGFja1toaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIHRpbWVzdGFtcCAtIGxhc3QudGltZXN0YW1wIDwgSElTVE9SWV9USU1FX0dBUCkge1xuICAgICAgICAgICAgICAgIC8vIEEgcHJldmlvdXMgZW50cnkgZXhpc3RzIGFuZCB3YXMgaW4gc2hvcnQgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCB0aGUgbGFzdCB3b3JkIGluIHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgdmFyIHJlID0gL1teYS16MC05XShbYS16MC05XSspJC9pO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcHJldmlvdXMgbGluZVxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IChfYSA9IGdldExpbmVzKGxhc3QudmFsdWUsIGxhc3Quc2VsZWN0aW9uU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC5wb3AoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKHJlKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gKF9iID0gZ2V0TGluZXMocmVjb3JkLnZhbHVlLCByZWNvcmQuc2VsZWN0aW9uU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC5wb3AoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hdGNoKHJlKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByZXZpb3VzID09PSBudWxsIHx8IHByZXZpb3VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91c1sxXSkgJiYgKChfYyA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFsxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXJ0c1dpdGgocHJldmlvdXNbMV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCB3b3JkIG9mIHRoZSBwcmV2aW91cyBsaW5lIGFuZCBjdXJyZW50IGxpbmUgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIHByZXZpb3VzIGVudHJ5IHNvIHRoYXQgdW5kbyB3aWxsIHJlbW92ZSB3aG9sZSB3b3JkXG4gICAgICAgICAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5zdGFja1toaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0XSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWNvcmQpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IG9wZXJhdGlvbiB0byB0aGUgc3RhY2tcbiAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50LnN0YWNrLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY29yZCksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSkpO1xuICAgICAgICBoaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0Kys7XG4gICAgfSwgW10pO1xuICAgIHZhciByZWNvcmRDdXJyZW50U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghaW5wdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNhdmUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW5wdXRcbiAgICAgICAgdmFyIHZhbHVlID0gaW5wdXQudmFsdWUsIHNlbGVjdGlvblN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgcmVjb3JkQ2hhbmdlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogc2VsZWN0aW9uRW5kLFxuICAgICAgICB9KTtcbiAgICB9LCBbcmVjb3JkQ2hhbmdlXSk7XG4gICAgdmFyIHVwZGF0ZUlucHV0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBVcGRhdGUgdmFsdWVzIGFuZCBzZWxlY3Rpb24gc3RhdGVcbiAgICAgICAgaW5wdXQudmFsdWUgPSByZWNvcmQudmFsdWU7XG4gICAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gcmVjb3JkLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSByZWNvcmQuc2VsZWN0aW9uRW5kO1xuICAgICAgICBvblZhbHVlQ2hhbmdlID09PSBudWxsIHx8IG9uVmFsdWVDaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVmFsdWVDaGFuZ2UocmVjb3JkLnZhbHVlKTtcbiAgICB9O1xuICAgIHZhciBhcHBseUVkaXRzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyBTYXZlIGxhc3Qgc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgIHZhciBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBsYXN0ID0gaGlzdG9yeVJlZi5jdXJyZW50LnN0YWNrW2hpc3RvcnlSZWYuY3VycmVudC5vZmZzZXRdO1xuICAgICAgICBpZiAobGFzdCAmJiBpbnB1dCkge1xuICAgICAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50LnN0YWNrW2hpc3RvcnlSZWYuY3VycmVudC5vZmZzZXRdID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxhc3QpLCB7IHNlbGVjdGlvblN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kOiBpbnB1dC5zZWxlY3Rpb25FbmQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSB0aGUgY2hhbmdlc1xuICAgICAgICByZWNvcmRDaGFuZ2UocmVjb3JkKTtcbiAgICAgICAgdXBkYXRlSW5wdXQocmVjb3JkKTtcbiAgICB9O1xuICAgIHZhciB1bmRvRWRpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gaGlzdG9yeVJlZi5jdXJyZW50LCBzdGFjayA9IF9hLnN0YWNrLCBvZmZzZXQgPSBfYS5vZmZzZXQ7XG4gICAgICAgIC8vIEdldCB0aGUgcHJldmlvdXMgZWRpdFxuICAgICAgICB2YXIgcmVjb3JkID0gc3RhY2tbb2Zmc2V0IC0gMV07XG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBjaGFuZ2VzIGFuZCB1cGRhdGUgdGhlIG9mZnNldFxuICAgICAgICAgICAgdXBkYXRlSW5wdXQocmVjb3JkKTtcbiAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5vZmZzZXQgPSBNYXRoLm1heChvZmZzZXQgLSAxLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlZG9FZGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBoaXN0b3J5UmVmLmN1cnJlbnQsIHN0YWNrID0gX2Euc3RhY2ssIG9mZnNldCA9IF9hLm9mZnNldDtcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGVkaXRcbiAgICAgICAgdmFyIHJlY29yZCA9IHN0YWNrW29mZnNldCArIDFdO1xuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgY2hhbmdlcyBhbmQgdXBkYXRlIHRoZSBvZmZzZXRcbiAgICAgICAgICAgIHVwZGF0ZUlucHV0KHJlY29yZCk7XG4gICAgICAgICAgICBoaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0ICsgMSwgc3RhY2subGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgICAgICAgb25LZXlEb3duKGUpO1xuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IGUuY3VycmVudFRhcmdldCwgdmFsdWUgPSBfYS52YWx1ZSwgc2VsZWN0aW9uU3RhcnQgPSBfYS5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kID0gX2Euc2VsZWN0aW9uRW5kO1xuICAgICAgICB2YXIgdGFiQ2hhcmFjdGVyID0gKGluc2VydFNwYWNlcyA/ICcgJyA6ICdcXHQnKS5yZXBlYXQodGFiU2l6ZSk7XG4gICAgICAgIGlmIChlLmtleSA9PT0gJ1RhYicgJiYgIWlnbm9yZVRhYktleSAmJiBjYXB0dXJlKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZvY3VzIGNoYW5nZVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmluZGVudCBzZWxlY3RlZCBsaW5lc1xuICAgICAgICAgICAgICAgIHZhciBsaW5lc0JlZm9yZUNhcmV0ID0gZ2V0TGluZXModmFsdWUsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lXzEgPSBsaW5lc0JlZm9yZUNhcmV0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZExpbmVfMSA9IGdldExpbmVzKHZhbHVlLCBzZWxlY3Rpb25FbmQpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBzdGFydExpbmVfMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaSA8PSBlbmRMaW5lXzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUuc3RhcnRzV2l0aCh0YWJDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcodGFiQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gbGluZXNCZWZvcmVDYXJldFtzdGFydExpbmVfMV07XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5RWRpdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5leHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHN0YXJ0IGN1cnNvciBpZiBmaXJzdCBsaW5lIGluIHNlbGVjdGlvbiB3YXMgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IHdhcyBtb2RpZmllZCBvbmx5IGlmIGl0IHN0YXJ0ZWQgd2l0aCBhIHRhYlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IChzdGFydExpbmVUZXh0ID09PSBudWxsIHx8IHN0YXJ0TGluZVRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXJ0TGluZVRleHQuc3RhcnRzV2l0aCh0YWJDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZWN0aW9uU3RhcnQgLSB0YWJDaGFyYWN0ZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGVuZCBjdXJzb3IgYnkgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQgLSAodmFsdWUubGVuZ3RoIC0gbmV4dFZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmRlbnQgc2VsZWN0ZWQgbGluZXNcbiAgICAgICAgICAgICAgICB2YXIgbGluZXNCZWZvcmVDYXJldCA9IGdldExpbmVzKHZhbHVlLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZV8yID0gbGluZXNCZWZvcmVDYXJldC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lXzIgPSBnZXRMaW5lcyh2YWx1ZSwgc2VsZWN0aW9uRW5kKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gbGluZXNCZWZvcmVDYXJldFtzdGFydExpbmVfMl07XG4gICAgICAgICAgICAgICAgYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gc3RhcnRMaW5lXzIgJiYgaSA8PSBlbmRMaW5lXzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFiQ2hhcmFjdGVyICsgbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBzdGFydCBjdXJzb3IgYnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYWRkZWQgaW4gZmlyc3QgbGluZSBvZiBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgbW92ZSBpdCBpZiBpdCB0aGVyZSB3YXMgbm8gdGV4dCBiZWZvcmUgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzdGFydExpbmVUZXh0ICYmIC9cXFMvLnRlc3Qoc3RhcnRMaW5lVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZWN0aW9uU3RhcnQgKyB0YWJDaGFyYWN0ZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBlbmQgY3Vyc29yIGJ5IHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogc2VsZWN0aW9uRW5kICsgdGFiQ2hhcmFjdGVyLmxlbmd0aCAqIChlbmRMaW5lXzIgLSBzdGFydExpbmVfMiArIDEpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCArIHRhYkNoYXJhY3Rlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0YWIgY2hhcmFjdGVyIGF0IGNhcmV0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYkNoYXJhY3RlciArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiB1cGRhdGVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICB2YXIgaGFzU2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHZhciB0ZXh0QmVmb3JlQ2FyZXQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgaWYgKHRleHRCZWZvcmVDYXJldC5lbmRzV2l0aCh0YWJDaGFyYWN0ZXIpICYmICFoYXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgZGVsZXRlIGJlaGF2aW91clxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZFNlbGVjdGlvbiA9IHNlbGVjdGlvblN0YXJ0IC0gdGFiQ2hhcmFjdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBhcHBseUVkaXRzKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRhYiBjaGFyYWN0ZXIgYXQgY2FyZXRcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCAtIHRhYkNoYXJhY3Rlci5sZW5ndGgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogdXBkYXRlZFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgLy8gSWdub3JlIHNlbGVjdGlvbnNcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGdldExpbmVzKHZhbHVlLCBzZWxlY3Rpb25TdGFydCkucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsaW5lID09PSBudWxsIHx8IGxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmUubWF0Y2goL15cXHMrLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwgfHwgbWF0Y2hlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hlc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGluZGVudGF0aW9uIG9uIGluc2VydGluZyBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRlbnQgPSAnXFxuJyArIG1hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkU2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgKyBpbmRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBhcHBseUVkaXRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIgYXQgY2FyZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogdXBkYXRlZFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogdXBkYXRlZFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9QQVJFTlMgfHxcbiAgICAgICAgICAgIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9CUkFDS0VUUyB8fFxuICAgICAgICAgICAgZS5rZXlDb2RlID09PSBLRVlDT0RFX1FVT1RFIHx8XG4gICAgICAgICAgICBlLmtleUNvZGUgPT09IEtFWUNPREVfQkFDS19RVU9URSkge1xuICAgICAgICAgICAgdmFyIGNoYXJzID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9QQVJFTlMgJiYgZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGNoYXJzID0gWycoJywgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9CUkFDS0VUUykge1xuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzID0gWyd7JywgJ30nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzID0gWydbJywgJ10nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfUVVPVEUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IFsnXCInLCAnXCInXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzID0gW1wiJ1wiLCBcIidcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFX0JBQ0tfUVVPVEUgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjaGFycyA9IFsnYCcsICdgJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0ZXh0IGlzIHNlbGVjdGVkLCB3cmFwIHRoZW0gaW4gdGhlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kICYmIGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGFwcGx5RWRpdHMoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyc1swXSArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogc2VsZWN0aW9uRW5kICsgMixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoaXNNYWNMaWtlXG4gICAgICAgICAgICA/IC8vIFRyaWdnZXIgdW5kbyB3aXRoIOKMmCtaIG9uIE1hY1xuICAgICAgICAgICAgICAgIGUubWV0YUtleSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREVfWlxuICAgICAgICAgICAgOiAvLyBUcmlnZ2VyIHVuZG8gd2l0aCBDdHJsK1ogb24gb3RoZXIgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9aKSAmJlxuICAgICAgICAgICAgIWUuc2hpZnRLZXkgJiZcbiAgICAgICAgICAgICFlLmFsdEtleSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdW5kb0VkaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoaXNNYWNMaWtlXG4gICAgICAgICAgICA/IC8vIFRyaWdnZXIgcmVkbyB3aXRoIOKMmCtTaGlmdCtaIG9uIE1hY1xuICAgICAgICAgICAgICAgIGUubWV0YUtleSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREVfWiAmJiBlLnNoaWZ0S2V5XG4gICAgICAgICAgICA6IGlzV2luZG93c1xuICAgICAgICAgICAgICAgID8gLy8gVHJpZ2dlciByZWRvIHdpdGggQ3RybCtZIG9uIFdpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9ZXG4gICAgICAgICAgICAgICAgOiAvLyBUcmlnZ2VyIHJlZG8gd2l0aCBDdHJsK1NoaWZ0K1ogb24gb3RoZXIgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgICAgIGUuY3RybEtleSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREVfWiAmJiBlLnNoaWZ0S2V5KSAmJlxuICAgICAgICAgICAgIWUuYWx0S2V5KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZWRvRWRpdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9NICYmXG4gICAgICAgICAgICBlLmN0cmxLZXkgJiZcbiAgICAgICAgICAgIChpc01hY0xpa2UgPyBlLnNoaWZ0S2V5IDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBjYXB0dXJpbmcgdGFiIGtleSBzbyB1c2VycyBjYW4gZm9jdXMgYXdheVxuICAgICAgICAgICAgc2V0Q2FwdHVyZShmdW5jdGlvbiAocHJldikgeyByZXR1cm4gIXByZXY7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hID0gZS5jdXJyZW50VGFyZ2V0LCB2YWx1ZSA9IF9hLnZhbHVlLCBzZWxlY3Rpb25TdGFydCA9IF9hLnNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgPSBfYS5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHJlY29yZENoYW5nZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIG9uVmFsdWVDaGFuZ2UodmFsdWUpO1xuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVjb3JkQ3VycmVudFN0YXRlKCk7XG4gICAgfSwgW3JlY29yZEN1cnJlbnRTdGF0ZV0pO1xuICAgIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQgc2Vzc2lvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5OiBoaXN0b3J5UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgc2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gc2Vzc2lvbi5oaXN0b3J5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCByZXN0LCB7IHN0eWxlOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGVzLmNvbnRhaW5lciksIHN0eWxlKSB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogcHJlQ2xhc3NOYW1lLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBzdHlsZTogX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlcy5lZGl0b3IpLCBzdHlsZXMuaGlnaGxpZ2h0KSwgY29udGVudFN0eWxlKSB9LCAodHlwZW9mIGhpZ2hsaWdodGVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogaGlnaGxpZ2h0ZWQgKyAnPGJyIC8+JyB9IH1cbiAgICAgICAgICAgIDogeyBjaGlsZHJlbjogaGlnaGxpZ2h0ZWQgfSkpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIHsgcmVmOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gKGlucHV0UmVmLmN1cnJlbnQgPSBjKTsgfSwgc3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZXMuZWRpdG9yKSwgc3R5bGVzLnRleHRhcmVhKSwgY29udGVudFN0eWxlKSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgKyAodGV4dGFyZWFDbGFzc05hbWUgPyBcIiBcIi5jb25jYXQodGV4dGFyZWFDbGFzc05hbWUpIDogJycpLCBpZDogdGV4dGFyZWFJZCwgdmFsdWU6IHZhbHVlLCBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLCBvbktleURvd246IGhhbmRsZUtleURvd24sIG9uQ2xpY2s6IG9uQ2xpY2ssIG9uS2V5VXA6IG9uS2V5VXAsIG9uRm9jdXM6IG9uRm9jdXMsIG9uQmx1cjogb25CbHVyLCBkaXNhYmxlZDogZGlzYWJsZWQsIGZvcm06IGZvcm0sIG1heExlbmd0aDogbWF4TGVuZ3RoLCBtaW5MZW5ndGg6IG1pbkxlbmd0aCwgbmFtZTogbmFtZSwgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCByZWFkT25seTogcmVhZE9ubHksIHJlcXVpcmVkOiByZXF1aXJlZCwgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsIGF1dG9DYXBpdGFsaXplOiBcIm9mZlwiLCBhdXRvQ29tcGxldGU6IFwib2ZmXCIsIGF1dG9Db3JyZWN0OiBcIm9mZlwiLCBzcGVsbENoZWNrOiBmYWxzZSwgXCJkYXRhLWdyYW1tXCI6IGZhbHNlIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGNzc1RleHQgfSB9KSkpO1xufSk7XG52YXIgc3R5bGVzID0ge1xuICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgfSxcbiAgICB0ZXh0YXJlYToge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgcmVzaXplOiAnbm9uZScsXG4gICAgICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgTW96T3N4Rm9udFNtb290aGluZzogJ2dyYXlzY2FsZScsXG4gICAgICAgIFdlYmtpdEZvbnRTbW9vdGhpbmc6ICdhbnRpYWxpYXNlZCcsXG4gICAgICAgIFdlYmtpdFRleHRGaWxsQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgfSxcbiAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB9LFxuICAgIGVkaXRvcjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICBib3hTaXppbmc6ICdpbmhlcml0JyxcbiAgICAgICAgZGlzcGxheTogJ2luaGVyaXQnLFxuICAgICAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGZvbnRTdHlsZTogJ2luaGVyaXQnLFxuICAgICAgICBmb250VmFyaWFudExpZ2F0dXJlczogJ2luaGVyaXQnLFxuICAgICAgICBmb250V2VpZ2h0OiAnaW5oZXJpdCcsXG4gICAgICAgIGxldHRlclNwYWNpbmc6ICdpbmhlcml0JyxcbiAgICAgICAgbGluZUhlaWdodDogJ2luaGVyaXQnLFxuICAgICAgICB0YWJTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIHRleHRJbmRlbnQ6ICdpbmhlcml0JyxcbiAgICAgICAgdGV4dFJlbmRlcmluZzogJ2luaGVyaXQnLFxuICAgICAgICB0ZXh0VHJhbnNmb3JtOiAnaW5oZXJpdCcsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgIHdvcmRCcmVhazogJ2tlZXAtYWxsJyxcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBFZGl0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-simple-code-editor/lib/index.js\n");

/***/ })

};
;